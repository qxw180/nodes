# JavaScript 运行机制

1. JS引擎开始执行的时候会创建一个全局**执行上下文(Execution Context)**环境，JS引擎逐行执行代码，每一个函数执行的时候都会创建一个新的函数执行上下文
2. 上下文在创建后会被压入**执行环境栈(Execution Context Stack)**
3. JS引擎总会执行位于栈顶的上下文，函数运行完成之后JS引擎会将该函数创建的执行上下文弹出执行环境栈
4. 每个执行上下文中都有一个对象用来存储可访问的变量，即**变量对象(Variable Object)**，每进入一个执行上下文之后，该上下文重点变量对象就被激活了变量对象转化为**激活对象(Activation Object)**

## 执行上下文

执行上下文可分为：

1. 全局执行上下文
2. 函数执行上下文
3. Eval执行上下文

执行上下文是在代码执行开始之前创建的，主要包含以下三部分：

1. 变量对象，包括变量声明、函数声明、arguments对象
2. 作用域链
3. `this`关键字指向

在变量对象的创建过程中会发生变量提升

## 函数堆栈

## 异步非阻塞

JavaScript从设计开始就是一个单线程语言，这和它的设计初衷有关，只是为了处理一些简单的页面交互。单线程的问题就是任务是串行的，上一个任务未完成下一个任务就需要一直等待。在HTML页面中JS的执行也会阻塞页面渲染，所以在进行一些耗时操作如ajax请求等，js引擎线程就无法继续处理其它任务，页面就会假死，即线程**阻塞**。
所以JS才有异步任务（asynchronous callback）来解决这个问题。主线程在遇到异步任务时(如ajax请求)不需要等待结果返回，直接向下继续运行，当异步任务完成之后会以某种方式(例如callback)通知主线程并返回运行结果，这既是**异步非阻塞**。

现代浏览器一个tab页面一般包含以下线程：

+ GUI渲染线程
+ JS引擎线程
+ 事件触发线程
+ 定时器触发线程
+ 异步HTTP请求线程

JS 中的异步操作是通过 WebAPIs 去支持的，常见的有 XMLHttpRequest，setTimeout，事件回调（onclik, onscroll等）。而这几个 API 浏览器都提供了单独的线程去运行，所以才会有地方去做定时器的计时，request 的回调。

## 事件循环 Event Loop

## 函数执行栈

## 参考

[我理解的 JS 运行机制及 Event Loop](https://github.com/sunyongjian/blog/issues/38)
