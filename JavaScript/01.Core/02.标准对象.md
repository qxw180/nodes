#JavaScript标准对象



---
##函数

> 函数的声明和变量提升

	使用function命令声明函数
	function f1(attr){
		return attr;
	}

	使用变量赋值声明函数
	var f1 = function(attr){
		return attr;
	}

> 重复声明函数，后声明的函数会覆盖之前声明的函数；
> 使用function命令声明函数会发生变量提升

	function f() {
	  console.log(1);
	}
	f() // 2
	function f() {
	  console.log(2);
	}
	f() // 2

	// 相当于
	function f(){//变量提升
		console.log(1)
	}
	function f(){//函数覆盖
		console.log(2)
	}
	f(); //2
	f(); //2
---

#####函数的属性和方法
+ `.name`：返回函数的名称，使用变量声明的匿名函数返回值为`''`；
+ `.length`：返回函数定义的参数个数，可以利用这个属性实现面向对象编程中的“方法重载”
+ `.toString()`：返回函数的源代码，方法内部注释也会一同返回

#####函数的作用域
> JavaScript中只存在两种作用域，全局作用域和函数作用域

+ 全局作用域：在程序中一直存在；
+ 函数作用域：在函数内部声明的变量，只要在函数内部存在；

> 在函数内部声明的变量优先级高于全局变量

	var x = 1;
	function f(){
		var x = 2;
		console.log(x);
	}
	f(); // 2
> 在函数内部也同样会发生变量提升，其实函数每次执行都会产生一个执行上下文

	(function(){
		console.log(x);
		var x = 12;
	})()
	// 执行结果为unidined，但是不会报错


#####函数的参数
> JavaScript传入的参加个数可以和声明的参数个数不一致，函数的`.length`属性和可以返回声明的参数个数；
> 被忽略的参数的值就为`undefined`

	function f(a,b){
		return a;
	}

	f();//undefined;

> 设置默认值

	function f(a) {
	  (a !== undefined && a !== null) ? a = a : a = 1;
	  return a;
	}

> 同名参数：如果有相同参数名的参数，则取后出现的参数

> arguments对象：包含了函数运行时的所有参数

+ `.lenght`：运行时参数个数
+ `.callee`：返回对应得原函数


