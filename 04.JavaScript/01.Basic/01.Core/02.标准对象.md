#JavaScript标准对象

##[Object对象](http://javascript.ruanyifeng.com/stdlib/object.html)

####创建对象
+ `{}`：字面量写法
+ `new Object()`：构造函数
	* 出入参数为对象，则直接返回该对象，`var obj = {a:1};obj === new Object(obj);// true`；
	* 传入产生为元素类型，则返回该值的包装类；
	* 通过构造函数与字面量写法是等价的；
+ `Object.create(null)`：创建一个对象，并指定对象的原型

####对象的属性模型
ECMAScript5对应对象的属性都提出了一个精确的模型描述；
每个对象属性都有一个`attributes`对象，用来保存对象属性的描述，称为元信息；
可以通过`Object.getOwnPropertyDescriptor(obj,attr)`方法来获取

	var obj = {a:1};
	Object.getOwnPropertyDescriptor(obj,'a');
	// Object {value: 1, writable: true, enumerable: true, configurable: true}


> 对象属性的元信息主要包括以下内容：

+ `value`：属性的值，默认`undefined`
+ `writable`：表示`value`的值是否可以改变，默认`true`
+ `enumerable`：表示属性是否可枚举，默认`true`；如果设置为`false`在`for`循环和`Object.keys()`中将跳过该属性
+ `configurable`：表示属性是否可以配置，默认`true`；如果为`false`则
	* 不可以使用`delete`删除该属性
	* 除了`value`之外的元信息都不能修改
+ `get`：函数的默认取值函数，默认`undefined`
+ `set`：函数的默认赋值函数，默认`undefined`

#####设置对象属性元信息：
> `Object.defineProperty(object,propertyName,attributesObject)`
> `Object.defineProperties(object,attributesObject)`
	var o = Object.defineProperty({},a,{value:1,wirtable:true,enumerable:true,configurable:true});
	Object.defineProperties({},{
		a:{value:1,wirtable:true,enumerable:true,configurable:true},
		b:{
			wirtable:true,
			enumerable:true,
			configurable:true,
			get:function(){
				return this.a * 2;
			}
		},
	});
> `Object.defineProperty`和`Object.defineProperties`方法效率比较低；
> 设置`get/set`属性后不能将`wriable`设置为`false`，也不能设置`value`，否则会报错；
> `enumerable`、`enumerable`、`configurable`默认都为`false`；

---
#####获取对象属性
+ `Object.getOwnPropertyNames(object)`：获取全部属性，包括`enumerable:false`
+ `Object.keys(object)`：获取`enumerable`不为`false`的属性

---
#####属性验证
是否可枚举：`Object.prototype.propertyIsEnumerable()`

	var o = {};
	o.p = 123;

	o.propertyIsEnumerable("p") // true
	o.propertyIsEnumerable("toString") // false
---
####对象的状态控制
+ `Object.preventExtensions(object)`：阻止对象继续添加属性
+ `Object.isExtensible(object)`：判断对象是否可以添加属性
+ `Object.seal(object)`：锁死对象，无法添加属性，也无法删除属性
+ `Object.isSealed(object)`：判断对象是否锁死
+ `Object.freeze(object)`：冻结对象，无法添加删除属性，也无法修改属性的值
+ `Object.isFrozen(object)`：判断对象是否冻结

####原型链相关
+ `Object.create(proto,attrs)`：生成一个新对象，并该对象的原型。
	* `proto`:原型对象
	* `attrs`:是一个对象，声明了创建对象的属性,例：`{x:{writable:true}}`
+ `Object.getPrototypeOf(object)`：获取对象的Prototype对象。

####对象实例方法：
+ `valueOf()`：返回当前对象对应值，主要用途自动类型转换会调用该方法
	可以重写覆盖该方法实现自己想要的效果
	var o = new Object();
	o.valueOf = function (){return 2;};
	1 + o // 3
+ `toString()`：返回当前对象对应字符串形式，可以自定义toString方法，得到想要的字符串形式
+ `propertyIsEnumerable(attr)`：判断对象属性是否可枚举
+ `hasOwnProperty()`：判断某个属性是否为当前对象自身的属性
+ `isPrototypeOf()`：判断当前对象是否为另一个对象的原型

---
##函数

> 函数的声明和变量提升

	使用function命令声明函数
	function f1(attr){
		return attr;
	}

	使用变量赋值声明函数
	var f1 = function(attr){
		return attr;
	}

> 重复声明函数，后声明的函数会覆盖之前声明的函数；
> 使用function命令声明函数会发生变量提升

	function f() {
	  console.log(1);
	}
	f() // 2
	function f() {
	  console.log(2);
	}
	f() // 2

	// 相当于
	function f(){//变量提升
		console.log(1)
	}
	function f(){//函数覆盖
		console.log(2)
	}
	f(); //2
	f(); //2
---

#####函数的属性和方法
+ `.name`：返回函数的名称，使用变量声明的匿名函数返回值为`''`；
+ `.length`：返回函数定义的参数个数，可以利用这个属性实现面向对象编程中的“方法重载”
+ `.toString()`：返回函数的源代码，方法内部注释也会一同返回

#####函数的作用域
> JavaScript中只存在两种作用域，全局作用域和函数作用域

+ 全局作用域：在程序中一直存在；
+ 函数作用域：在函数内部声明的变量，只要在函数内部存在；

> 在函数内部声明的变量优先级高于全局变量

	var x = 1;
	function f(){
		var x = 2;
		console.log(x);
	}
	f(); // 2
> 在函数内部也同样会发生变量提升，其实函数每次执行都会产生一个执行上下文

	(function(){
		console.log(x);
		var x = 12;
	})()
	// 执行结果为unidined，但是不会报错


#####函数的参数
> JavaScript传入的参加个数可以和声明的参数个数不一致，函数的`.length`属性和可以返回声明的参数个数；
> 被忽略的参数的值就为`undefined`

	function f(a,b){
		return a;
	}

	f();//undefined;

> 设置默认值

	function f(a) {
	  (a !== undefined && a !== null) ? a = a : a = 1;
	  return a;
	}

> 同名参数：如果有相同参数名的参数，则取后出现的参数

> arguments对象：包含了函数运行时的所有参数

+ `.lenght`：运行时参数个数
+ `.callee`：返回对应得原函数


