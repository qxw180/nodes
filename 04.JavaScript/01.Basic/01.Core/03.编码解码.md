#JavaScript中的编码和解码

##为什么要有编码解码
计算机存储单元`比特bit`只能存储0和1，通过0和1的组合代表不同的信息；
这些0和1的组合人是不能够直接理解的，所以要把这些这些0，1进行转换，转换成文字、声音、图像等等；
在这里我们只考虑文本的转换，我们能够直接理解的符号就叫做`字符(Character)`，包括数字、字母、标点符号、汉字、阿拉伯字母等等等等，这些字符的集合就是`字符集(Character Set)`；
在信息的存储和网络传输的过程中我们要把字符转换成0和1的序列，这个转换过程就是`编码(Encoding)`
从硬盘和网络中读取的到的01序列要进过逆转换才能得到我们能够理解的信息，这个逆转换过程就是`解码(Decoding)`
编码和解码必须遵守同一套规范，如果规范不统一编解码过程就不能获取正确的信息，这个规范就是`字符编码(Character Encoding)`



##基本概念
+ 比特（bit）：也可称为“位”，是计算机信息中的最小单位，是 binary digit（二进制数位） 的 缩写，指二进制中的一位
+ 字节（Byte）：计算机中信息计量的一种单位，每8个位（bit）组成一个字节（Byte）
+ 字符（Character）：文字与符号的总称，可以是各个国家的文字、标点符号、图形符号、数字等
+ 字符集（Character Set）：是多个字符的集合
+ 编码（Encoding）： 信息从一种形式或格式转换为另一种形式的过程
+ 解码（decoding）： 编码的逆过程
+ 字符编码（Character Encoding）： 按照某种规则存储字符


##字符编码的发展的几个阶段

->第一阶段：ASCII及ASCII扩展
美国人发明了计算机，也创造了第一套字符编码[ASCII(American Standard Code for Information Interchange 美国信息交换标准码)](https://zh.wikipedia.org/wiki/ASCII)。
> 8个晶体管为一组，组成一个1Byte，可以产生256种组合；美国人使用其中的128种组合指定了ASCII，占用了0-127段；
> 占用一个Byte中的后七位，第一位为0，如A是65(01000001)B是66(01000010)；包括终端状态、标点符号、数字、英文大小写字母；

但是ASCII只能表示显示26个基本拉丁字母、阿拉伯数字和英式标点符号；然后欧洲人不乐意了，字母符号不够用啊。
欧洲人决定在ASCII上扩充了表格符号、计算符号、希腊字母和特殊的拉丁符号；0-127段和ASCII完全相同，不同的是添加了128-255段；
称为[EASCII(Extended ASCII 延伸美国标准信息交换码)](https://zh.wikipedia.org/wiki/EASCII)

->第二阶段：百花齐放
很快中国、日本、韩国等等很多国家都要使用计算机，所以EASCII也根本够用，所以就各自制定了一些列字符编码

+ `GB2312`：使用两个Byte表示一个汉字，共包含7445个字符，6763个汉字和682个其他字符（拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母）；
+ `BIG5`：同样使用两个字节表示，台湾繁体字符编码，共收录13,060个汉字及441个符号；
+ `GBK`：GB2312的扩展，包括`GB2312`和`BIG5`


->第三阶段：万宗归一
很快这种百发齐放的繁荣就暴露了出了问题，各个国家都在定制自己的字符编码，乱成一锅粥了，同一个二进制在不同的编码放方案下表示的是不同的字符；
这时一些国际组织站出来做编码统一这件事，包括国际标准化组织(ISO)和统一码联盟(IEC)，这里面的故事感兴趣的话可以自己上网查找；
最后制定了[Unicode(国际码)](https://zh.wikipedia.org/wiki/Unicode)，1991年发布了第一版(不包括CJK字符)，
Unicode是定长编码，所有的字符都使用4个字节编码；
Unicode从0开始为每个符号指定了一个编号，叫做“码点”；例如码点0的符号就是null`U+0000 = null`；

->第四阶段：完善
Unicode似乎是统一了字符编码，解决了乱码的问题。
但是Unicode只规定了符号的二进制代码，没有规定这个二级制代码应该如何存储；
比如汉字“严”的十六进制数是`4E25`,转换为二级制是`100111000100101`共15位，至少需要2个Byte，但是也可以使用3个或4个Byte；
那么问题来了：
	1. 如何区分Unicode和ASCII，计算机无法判别三个Byte是表示一个Unicode字符还是三个ASCII字符
	2. 假设规定使用三个Byte表示一个Unicode字符，那么对于英文字母和数字这种使用一个Byte就可以表示的字符是极大的浪费

很多厂商都有自己的Unicode存储方案，最后形成了多种Unicode编码实现方案，UTF-8是互联网使用最广的一种方式；
	UTF-8：变长编码方案，1~4Byte变长编码方案
	UTF-16：使用2Byte和4Byte变长编码
		第一平面使用2Btye
		其它平面使用4Btye
	UTF-32：使用4Btye对应一个码点

##UTF-8
> UTF-8是Unicode的实现方式之一，UTF-8是一种变长的编码方式
> 1) 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码，所以对于英语字母，UTF-8编码与ASCII编码是完全相同的
> 2) 对于n字节的符号，第一个字节的前n为都设为1，第n+1为设为0，后面字节的前两位一律设置为10。剩下的位提取出来即为这个符号的Unicod编码

例子：
以“严”字为例，Unicode编码为4E25(100 1110 0010 0101)
需要3个字节来存储，所有形式即为`1110 xxxx 10xx xxxx 10xx xxxx`
                         填充后`1110 0100 1011 1000 1010 0101`
                 转换为十六进制`E4B8A5`
“严”的Unicode编码为`4E25`，UTF-8编码为`E4B8A5`，二者的编码并不相同，是通过程序转换的


	
##JavaScript使用的编码
JavaScript使用Unicode字符集，但是使用UCS-2编码方案

UCS-2是什么鬼？
ISO/IEC搞了Unicode字符集之后有搞了一个UCS，之间的乱七八糟的事情查资料也是看的一头雾水，反正Unicode与UCS编码方案是一致的，可以历届为同一个超大的字符集；
UCS-2是UCS的一种实现方案，使用2个字节；另外还有UCS-4：使用四个字节；
但是发布时间较早，只实现了Unicode的第一个平面；之后推出的UTF-16是UCS-2的超集，同样使用2Byte实现第一平面，使用4Byte实现其它平面；
UTF-32等同于UCS-4，UCS-4是UTF-32的超级；

因为JavaScript出现的时候还没有UTF-16，所以...；
带来的问题：
	JavaScript只能处理UCS-2编码，如果遇到4Btye的字符会当作两个字符来处理

中文：张三
Unicode：\u5f20\u4e09
UTF-8：&#x5F20;&#x4E09;

##前端开发需要处理的编码问题
 一、Coding时的编码问题
使用文本编辑器或者IDE进行Coding保存后的代码文件实际上就是一个二进制文件，一般在文件的开头会有几位来标识二进制文件存储的编码方案。
再次打开文件的时候如果解码方案和编码方案不一致的话就会出现乱码

 二、HTTP网络编码问题
如果编码和解码不一致也会出现乱码，HTTP编码设置主要包括一下几类
`<meta charset="gb2312"> //html5`
`<meta http-equiv="Content-Type" content="text/html; charset=gb2312"> //html4 xhtml`
`<script src="http://ossweb-img.qq.com/images/js/foot.js" charset="gb2312"></script>`
`<link href="http://gameweb-img.qq.com/css/common.css" rel="stylesheet" charset="gb2312" >`


##URL编码
URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号；
URL中如果有汉字就必须编码后使用；
在不同的浏览器中针对不同请求(资源请求、条件查询、get、post、ajax..)使用的编码方式不同，太崩溃了，所以在发送前要在浏览器之前进行编码，让浏览器歇着；
+ `escape()`和`unescape()`：已经不建议使用
	* 作用：返回*Unicode编码值*，除ASCII字母、数字、标点符号"@ * _ + - . /"以外，对其他所有字符进行编码；
+ `encodeURI`和`decodeURI`：URL编码
	* 作用：返回*utf-8形式*，对常见符号以及一些网址中一些特殊符号(; / ? : @ & = + $ , #)不进行编码
+ `encodeURIComponent`和`decodeURIComponent`：对整个URL进行编码，包括特殊字符(; / ? : @ & = + $ , #)
	



参考文献
[字符编码笔记：ASCII，Unicode和UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)
[字符编码的前世今生](http://www.smallni.com/character-encoding/)
[Unicode与JavaScript详解](http://www.ruanyifeng.com/blog/2014/12/unicode.html)
[关于URL编码](http://www.ruanyifeng.com/blog/2010/02/url_encoding.html)