#JavaScript基础-变量&常量
> 在应用程序中，使用变量来为值命名，称为标识符(indentifiers)；
> 常量是一个只读(read-only)的值的标识符；
> JavaScript标识符规则同Java一致：包含数组、字母、$、_，不以数组开头，区分大小写；

##声明

`变量`：在JavaScript中有三种变量声明方式
1. 使用关键字`var`：声明全局变量和局部变量；
2. 直接赋值：声明全局变量，这种方式是不推荐的，在严格模式下会报错；
3. 使用关键字`let`：在语句块内声明局部变量；

`常量`：在ES6之前JavaScript不支持常量，ES6支持使用关键字`const`来声明常量；

`重复声明`：
+ 使用`var`重复声明变量相当于什么都没做
+ 使用`let`和`const`进行重复声明会报错

	{
		let a = 1;
		let a;// 报错 SyntaxError: Identifier 'a' has already been declared
	}

##赋值
`变量`：声明后未赋值的变量默认值为`undefined`
	
	var a;
	cosnole.log(a);// 输出 undefined

`常量`：在声明常量的时候必须被初始化，常量在声明后不能在重新被赋值

	const a;// 报错 Uncaught SyntaxError: Missing initializer in const declaration
	const a = 1;
	a = 2;// 报错 Uncaught TypeError: Assignment to constant variable.(…)
	


##作用域
`局部变量`：在函数内部声明的变量为局部变量，只能在函数内部使用；
`全局变量`：在其它位置声明的变量均为全局变量，可以在任意位置访问；
	
	if(true) {
		var a = 1;
	}
	function tt(){
		var b = 2;
		console.log(b);
	}

	tt();// 输出2
	console.log(a);// 输出 1
	console.log(b);// 报错：Uncaught ReferenceError: b is not defined(…)

`块作用域`：
在ES6之前没有语句块作用域，只有函数作用域；
使用ES6规范的关键字`let`可以声明块作用域的局部变量

	if(true) {
		let a = 1;
		console.log(a);// 输出 1
	}
	console.log(a);// 报错：Uncaught ReferenceError: a is not defined(…)

常量的作用域与`let`块作用域相同；


##变量提升 variable histing
> 在JavaScript中可以引用稍后声明的变量，
> JavaScript会把使用`var`和`function`关键字声明的变量提升到全局或方法的顶部

###JavaScript 变量提升和执行上下文

`变量提升(hoisting)`：
JavaScript引擎运行方式是先解析代码，获取所有被声明的变量，然后再一行一行的运行。所有的变量声明语句都会被提升到代码的头部；

	console.log(a);//undefined
	var a = 1;
	
	在解析过程变量a被提升到console之前，但是赋值不会被提升；相当于
	var a;
	console.log(a);
	a = 1;
	所以结果为`undefined`

变量提升只对`var`语句有效

	console.log(b);//Uncaught ReferenceError: b is not defined(…)
	b = 2;
	JavaScript不会对b = 2进行变量提升，只认为这是一个赋值语句；


`JavaScript引擎工作方式`：
JavaScript引擎运行过程分为预编译期和执行器
在预编译期会生成执行上下文
生成执行上下文的过程就是变量提升的过程


###执行上下文 Execution Context
>执行上下文有三种
+ 全局上下文
+ 函数执行上下文
+ eval执行上下文
其中只有一个全局上下文，可能有多个函数执行上下文和eval执行上下文
每次函数执行都会生成具有不同状态的执行上下文

###执行上下文栈
> 一个执行上下文可能触发另一个上下文，比如一个函数调用另一个函数，
> 这些上下文是以栈的形式呈现，叫做执行上下文栈；

+ 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，
+ 作用域链的变量只能向上访问，变量访问到window对象即被终止，
+ 作用域链向下访问变量是不被允许的。

###变量对象 Variable Object
> VO 是一个抽象概念中的对象，用于存储执行上下文中的变量、函数声明和函数参数；

	var a = 10;      		VO(globalContext) = {
	function test(x){			a:10,
		var b = 20;				test:<ref to function>
	}						};	
	test(30);				VO(test functionContext){
								x:30,
								b:10
							}
> VO的执行顺序如下

1. 函数参数(若未传入，初始化该参数的职位`undefined`)
2. 函数声明(若发生命名冲突，会覆盖)
3. 变量声明(初始化变量值为`undefined`，若发生命名冲突会忽略)

例：

	alert(x); // function x(){} 函数重复声明，覆盖var x

	var x = 10;
	alert(x);// 10 允许时变量赋值
	x = 20;

	function x(){}
	alert(x);// 20

	if(true){
		var a = 1;
	}else{
		var b = true;
	}

	alert(a);// 1
	alert(b);// undefined 变量初始化后为执行赋值

##JavaScript上下文 this
+ 以对象的方法形式调用，this指向被调用的对象；
+ 以单独函数调用，this指向全局变量；
	* 在`use strict`模式下`this`指向`undefined`，可以暴露错误；
+ 使用函数的`apply()`方法可以控制this的指向
	* 第一个参数就是需要绑定的this变量；
	* 第二个参数是Array，表示函数本身的参数；
	* `call()`方法与`apply()`方法功能一直，唯一的区别是`apply()`把参数打包成Array再传入，`call()`把参数按顺序传入。


##参考文献
[JavaScript核心](http://weizhifeng.net/javascript-the-core.html#execution-context-stack)