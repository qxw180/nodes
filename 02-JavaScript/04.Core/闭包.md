# JavaScript闭包

定义一个方法，方法的返回值为一个函数，返回函数的内部引用方法内部变量，如下：

``` JavaScript
function outer(){
    var a = 1;
    function inner(){
        return a;
    }
    return inner;
}
var f = outer();
console.log(f());// 1
```

闭包的本质还是一个函数，特殊的地方是这个函数包含了一个上下文环境(返回函数内部引用的所有变量)。

## 为什么要这么写

首先闭包可以实现在函数外部获取函数内部的变量的值；
难道闭包就是为了这个？当然不是了。闭包最主要的目的是为了能够保存函数的运行状态

``` JavaScript
function outer(){
    var a = 1;
    function inner(){
        return a++;
    }
    return inner;
}

var f = outer();

console.log(f());// 1
console.log(f());// 2
console.log(f());// 3
```

这样`outer`方法内部变量`a`就可保存状态了，每调用一次就自增1；

## 闭包为什么可以保存状态

闭包的这种特性和JavaScript的内存回收机制有关，JavaScript会对没有引用的变量进行垃圾回收，例如：

``` js
var obj = {
    a:1,
    b:2
}
// 这时obj和对象之间存在着引用关系
obj = null;
// 这时obj对对象之间的引用关系就不存在了，对象就会被JavaScript引擎当作垃圾消耗
```

函数在执行完成后函数内部变量也会被回收，只保留全局变量；
在闭包中函数`outer`允许完成后将内部函数变量`inner`作为返回值返回，
这样全局变量 `f` 和 闭包函数`inner`形成引用关系，`inner`函数在`outer`函数内部，
这样JavaScript引擎因为这之间的引用关系不会进行垃圾回收，就可以到达保存允许状态的目的

## 闭包的优点

可以做到在不污染全局变量的情况下实现运行状态的保留

## 闭包的缺点

会增大内存的使用量，使用不当会造成内存泄漏；

## 使用场景

关于闭包的使用场景。。个人认为都可以使用OOP来替代，闭包实在让人难以理解控制；
