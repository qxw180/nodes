# 需要注意的基本语法

## `switch`

```js
switch (sport) {
  case "basketball":
    console.log("Tall Man");
  case "football":
    console.log("Fast Man");
  default:
    console.log("Not Either");
}
```

- `case`语句在进行匹配是使用的是`===`匹配；
- 如果`case`语句没有匹配，则会执行`default`语句中的内容；
- `case`语句内的`break`不能少，否则语句会在匹配后执行之后所有`case`和`default`语句中的内容；

## `for`和`Object.keys()`的区别

`for`：会遍历对象继承自原型的属性和方法
`Object.keys()`：只获取对象本身的属性

## `break`、`continue`和`return`

- `break`：跳出循环
- `continue`：结束本次循环，进行下一次循环
- `return`：跳出方法，并返回值

## JavaScript 严格模式

- 变量必须声明后再使用；
- 函数的参数不能同名；
- 不能使用`with`语句；
- 不能对只读属性赋值；
- 不能删除不可删除的属性；
- 不能使用前缀 0 表示八进制；
- `this`不能指向全局对象，默认为`undefined`;
- 不允许使用`label`；
- 对`wirtable`属性为`false`进行修改会报错，非严格模式不会报错也不会生效；
- 不可以` delete``congifrable `为`false`的属性；

## IIFE 立即调用函数表达式

形成独立作用域，避免污染全局变量

```js
(function () {
  var a = 123;
})();
```

## eval 命令

`eval()`命令可以把字符串当作语句执行；`eval()`没有自己的作用域，执行作用域为当前作用域

```js
var a = 1;
eval("a=2");
console.log(a); // 2
```

`eval()`不会得到 JavaScript 引擎优化，运行速度较慢，`eval()`间接调用作用域为全局作用域

```js
var a = 1;
function f() {
  var a = 2;
  var e = eval;
  e("console.log(a)");
}
f(); // 1
```
