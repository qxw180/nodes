# JavaScript 运行机制

## 同步任务执行机制

1. JS引擎开始执行的时候会创建一个全局**执行上下文(Execution Context)**环境，JS引擎逐行执行代码，每一个函数执行的时候都会创建一个新的**函数执行上下文**
2. 执行上下文在创建后会被压入**执行环境栈(Execution Context Stack)**
3. JS引擎总会执行位于栈顶的执行上下文，函数运行完成之后JS引擎会将该函数创建的执行上下文弹出执行环境栈
4. 每个执行上下文中都有一个对象用来存储可访问的变量，即**变量对象(Variable Object)**，JS引擎每进入一个执行上下文之后，该上下文的变量对象就被激活了变量对象转化为**激活对象(Activation Object)**

### 执行上下文

根据执行代码的区别，执行上下文可分为：

1. 全局执行上下文
2. 函数执行上下文
3. Eval执行上下文

执行上下文是在代码执行开始之前创建的，主要包含以下三步：

1. Step 1:变量对象，在这个过程会发生变量提升
   1. Step 1.1：创建arguments对象，检查上下文初始化参数名称和值并**创建引用的复制**
   2. Step 1.2：提升函数声明，将声明的函数在变量对象上创建一个属性，属性名为函数名，值为该函数的引用，，如果**重复声明则会覆盖**
   3. Step 1.3：提升变量声明，将声明的变量在变量对象上创建一个属性并初始化值为undefined，如果**重复声明则跳过**
2. Step 2：创建作用域链
3. Step 3：确定`this`关键字指向

### 执行环境栈

因为JS为单线程的，在同一时间只能执行一个任务，所以JS引擎会为每一次执行(一个JS文件，一个函数)创建一个**执行上下文**用来存储执行的环境，创建后压入**执行环境栈**的顶部。压栈完成后JS引擎会从栈顶开始逐个执行每一个上下文，一个上下文执行完成之后会立刻从执行环境栈弹出，并执行下一个上下文。

## 异步任务执行机制

JavaScript是单线程语言，Event Loop是JavaScript的异步执行机制

### 异步非阻塞

JavaScript是一个单线程语言，单线程的问题就是任务是串行的，上一个任务未完成下一个任务就需要一直等待，所以在进行一些耗时操作如ajax请求等，js引擎线程就无法继续处理其它任务，页面就会假死，即**线程阻塞**。

JavaScript使用异步任务（asynchronous callback）来解决这个问题。主线程通过API创建异步任务(如ajax请求)，API会在其它线程运行任务，主线程不需要等待结果返回，直接向下继续运行，这就是**非阻塞调用**。异步任务完成操作有两种方式：

1. 主线程不定时查看任务完成状态。
2. **异步I/O模式**：异步任务完成当异步任务完成之后会以某种方式(通常为callback)通知主线程，主线程如果处于空闲状态就会接收返回结果

现代浏览器一个tab页面一般包含以下线程：

+ GUI渲染线程
+ JS引擎线程
+ 事件触发线程
+ 定时器触发线程
+ 异步HTTP请求线程

JS 中的异步操作是通过 WebAPIs 去支持的，常见的有 `XMLHttpRequest`，`setTimeout`，`事件回调（onclik, onscroll）`等。而这几个 API 浏览器都提供了单独的线程去运行，所以才会有线程去做定时器的计时，request的回调等。**这些线程和JavaScript引擎线程不是同一线程，是浏览器实现了它们之间的通信**

### 任务队列(Task Queue)和事件循环(Event Loop)

异步任务执行完成之后会通知主线程，主线程通过callback获取执行结果。但是如果主线程处于以非空闲状态就无法接收异步通知，这时异步任何会将callback存放在**任务队列**，主线程空闲后会从任务队列取出第一个callback并执行，执行完成之后会继续去任队列取出callback并执行，这种机制就是**事件循环**。在ES6标准中又添加了**工作队列**的概念，用来存放Promise异步任务，工作队列和任务队列的区别是，工作队列的优先级更高，主线程有优先处理工作队列中的任务。

### 宏任务(macro task)和微任务(micro task)

前面提到过任务队列和工作队列，异步任务分为宏任务、微任务，不同类型的任务会将callback添加到不同的队列。

宏任务：callback会压入任务队列，常见的宏任务包括：XHR回调、事件回调、`setTimeout/setInterval`
微任务：callback会压入工作队列，常见的微任务包括：`Promise.then()`

## 参考

[我理解的 JS 运行机制及 Event Loop](https://github.com/sunyongjian/blog/issues/38)
