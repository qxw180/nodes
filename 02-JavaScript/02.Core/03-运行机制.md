# JavaScript 运行机制

JavaScript 是**解释型语言**，不需要编译，在执行的过程中实时编译。
**JavaScript 引擎**负责在运行的过程中将 JS 代码转换成可执行的机器码，常用的 JavaScript 引擎有：

1. Chrome V8 引擎 (chrome、Node、Opera）
2. SpiderMonkey （Firefox）
3. Nitro (Safari）
4. Chakra （Edge)

JavaScript 引擎只能完成语言的解析和运行，我们的程序通常需要调用一些 API(如 DOM 操作、文件操作、网络操作)来实现业务需求。这些 API 是由 **JavaScript runtime** 提供的。

JavaScript 引擎和 JavaScript runtime 构成了 JavaScript 程序的运行环境。

- JavaScript 引擎负责解析 JS 代码，转为可执行的机器语言
- JavaScript runtime 暴露一些 API，供 JavaScript 调用

常见的运行环境：web 浏览器、NodeJS

JavaScript 是**单线程**，JavaScript 最开始被设计为浏览器脚本语言，主要用来处理用户交互和操作 DOM，场景相对简单，为了避免多线程的复杂同步问题(例：两个函数同时操作同一对象)，所以从诞生就是单线程的。HTML5 提出 [Web Worker](../../html/../03-Html/Worker/Web%20Worker.md) 标准用来利用多 CPU 能力处理 CPU 密集型任务。
// TODO，NodeJS 多线程

## JavaScript 引擎运行机制

### 主线程、同步任务、异步任务、任务队列和 Event Loop

JavaScript 引擎在代码解析完成之后会逐行运行，JavaScript 是单线程的，**主线程**同一时间只能执行一个任务。如果一个任务耗时很长，后面的任务就只能排队等待，通常情况下这些耗时任务一般都不是 CPU 耗时而是 IO 耗时(如 AJAX 网络请求)，CPU 在空闲等待。JavaScript 引擎可以挂起处于等待中的 IO 任务继续向下执行，等 IO 返回结果后再运行这些挂起的任务。

在主线程中排队执行的任务就是**同步任务(synchronous)**，在主线程之外还有一个**任务队列(task queue)**，被挂起的任务称为**异步任务(asynchronous)**会被放入任务队。

异步任务执行完成之后会在任务队列中放置一个事件，主线程执行完同步任务后会读取任务队列中的事件，并将事件对应的任务加入主线程执行，执行完成之后继续检查任务队列，这个过程就是**Event Loop**。

### 同步任务执行机制和执行栈

1. JS 引擎开始执行的时候会创建一个全局**执行上下文(Execution Context)**环境，JS 引擎逐行执行代码，每一个函数执行的时候都会创建一个新的**函数执行上下文**
2. 执行上下文在创建后会被压入**执行环境栈(Execution Context Stack)**
3. JS 引擎总会执行位于栈顶的执行上下文，函数运行完成之后 JS 引擎会将该函数创建的执行上下文弹出执行环境栈
4. 每个执行上下文中都有一个对象用来存储可访问的变量，即**变量对象(Variable Object)**，JS 引擎每进入一个执行上下文之后，该上下文的变量对象就被激活了变量对象转化为**激活对象(Activation Object)**

### 执行环境栈

JavaScript 是单线程的，也就是说在同一时间只能执行一个任务，所以 JS 引擎会为每一次执行(一个 JS 文件，一个函数)创建一个**执行上下文**用来存储执行的环境，创建后压入**执行环境栈**的顶部。压栈完成后 JS 引擎会从栈顶开始逐个执行每一个上下文，一个上下文执行完成之后会立刻从执行环境栈弹出，并执行下一个上下文。

### 执行上下文和作用域

根据执行代码的区别，执行上下文可分为：

1. 全局执行上下文
2. 函数执行上下文
3. Eval 执行上下文

执行上下文是在代码执行开始之前创建的，主要包含以下三步：

1. Step 1:变量对象，在这个过程会发生变量提升
   1. Step 1.1：创建 arguments 对象，检查上下文初始化参数名称和值并**创建引用的复制**
   2. Step 1.2：提升函数声明，将声明的函数在变量对象上创建一个属性，属性名为函数名，值为该函数的引用，，如果**重复声明则会覆盖**
   3. Step 1.3：提升变量声明，将声明的变量在变量对象上创建一个属性并初始化值为 undefined，如果**重复声明则跳过**
2. Step 2：创建作用域链
3. Step 3：确定`this`关键字指向

### 异步任务执行机制 Event Loop

JavaScript 是单线程语言，Event Loop 是 JavaScript 的异步执行机制

### 异步非阻塞

JavaScript 是一个单线程语言，单线程的问题就是任务是串行的，上一个任务未完成下一个任务就需要一直等待，所以在进行一些耗时操作如 ajax 请求等，js 引擎线程就无法继续处理其它任务，页面就会假死，即**线程阻塞**。

JavaScript 使用异步任务（asynchronous callback）来解决这个问题。主线程通过 API 创建异步任务(如 ajax 请求)，API 会在其它线程运行任务，主线程不需要等待结果返回，直接向下继续运行，这就是**非阻塞调用**。异步任务完成操作有两种方式：

1. 主线程不定时查看任务完成状态。
2. **异步 I/O 模式**：异步任务完成当异步任务完成之后会以某种方式(通常为 callback)通知主线程，主线程如果处于空闲状态就会接收返回结果

现代浏览器一个 tab 页面一般包含以下线程：

- GUI 渲染线程
- JS 引擎线程
- 事件触发线程
- 定时器触发线程
- 异步 HTTP 请求线程

JS 中的异步操作是通过 WebAPIs 去支持的，常见的有 `XMLHttpRequest`，`setTimeout`，`事件回调（onclik, onscroll）`等。而这几个 API 浏览器都提供了单独的线程去运行，所以才会有线程去做定时器的计时，request 的回调等。**这些线程和 JavaScript 引擎线程不是同一线程，是浏览器实现了它们之间的通信**

### 任务队列(Task Queue)和事件循环(Event Loop)

异步任务执行完成之后会通知主线程，主线程通过 callback 获取执行结果。但是如果主线程处于以非空闲状态就无法接收异步通知，这时异步任何会将 callback 存放在**任务队列**，主线程空闲后会从任务队列取出第一个 callback 并执行，执行完成之后会继续去任队列取出 callback 并执行，这种机制就是**事件循环**。在 ES6 标准中又添加了**工作队列**的概念，用来存放 Promise 异步任务，工作队列和任务队列的区别是，工作队列的优先级更高，主线程有优先处理工作队列中的任务。

### 宏任务(macro task)和微任务(micro task)

前面提到过任务队列和工作队列，异步任务分为宏任务、微任务，不同类型的任务会将 callback 添加到不同的队列。

宏任务：callback 会压入任务队列，常见的宏任务包括：XHR 回调、事件回调、`setTimeout/setInterval`
微任务：callback 会压入工作队列，常见的微任务包括：`Promise.then()`

## 参考

[JavaScript 运行机制详解：再谈 Event Loop](https://www.ruanyifeng.com/blog/2014/10/event-loop.html)
[我理解的 JS 运行机制及 Event Loop](https://github.com/sunyongjian/blog/issues/38)
