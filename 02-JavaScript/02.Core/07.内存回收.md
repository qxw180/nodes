# JavaScript GC

垃圾回收（Garbage Collection，缩写为 GC）即内存回收，是一种自动的存储器管理机制。当某个程序占用一部分内存不再被程序访问时程序会释放这部分内存。垃圾回收实现方式有两种：

1. 引用计数：最早的也是最简单的垃圾回收实现方法，这种方法为占用物理空间的对象附加一个计数器，当有其他对象引用这个对象时计数器加一，反之引用解除时减一。垃圾回收器会定期检查，技术为零的对象会被释放。缺点是：**无法回收循环引用的存储对象**
2. 标记清除法：定时从根部(window)对象扫描对象，凡是能够到达的对象都是还需要继续使用的，那些无法到达的对象会被标记为不再使用，稍后会被回收
   1. 垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记
   2. 从根部出发将能触及到的对象的标记清除
   3. 那些还存在标记的变量被视为准备删除的变量
   4. 最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间

不在使用的内存没有及时释放就是**内存泄漏**，内存泄漏容易导致内存溢出使程序崩溃。以下情况会发生内存泄漏：

- 意外全局变量：解决方案使用严格模式
  - 在非严格模式下当引用未声明的变量时，会在全局对象中创建一个新变量
  - 使用`this`创建变量
- 未被清理的定时器`setInterval`，执行过程中会不断地占用内存
- `DOM`引用：`DOM`元素被移除后，JS 变量引用会导致无法进行内存回收，`DOM`的变量在使用后可以赋值为`null`
- 闭包

```JS 全局变量案例
function fn () {
  a = "Actually, I'm a global variable"
}
function fn () {
  this.a = "Actually, I'm a global variable"
}
fn();
```

```JS 未清理定时器案例
var serverData = loadData();
setInterval(function() {
  var root = document.getElementById('root');
  if(root) {
    root.innerHTML = JSON.stringify(serverData);
  }
}, 5000); // 每 5 秒调用一次
```

以上代码问题：如果`root`元素被移除后，定时器实际没有任何作用，但是定时器没有被回收导致定时器的回调函数以及回调函数内部的变量引用(本例中的 `serverData`)也无法被回收。

## TODO:内存泄漏检测

- 开发工具：
