# JavaScript错误处理机制

## 同步任务错误处理

### Error对象

Error对象是JavaScript的原生对象，当代码解析或运行时发生错误，JavaScript引擎就会自动产生并抛出一个error对象实例，然后在错误发生的地方中断程序；一般包含以下属性：

+ `name`：错误名称
+ `message`：错误提示信息
+ `stack`：错误的堆栈（非标准属性，但是大多数平台支持）

### 原生错误类型

1. `SyntaxError`：解析代码错误，写错了
2. `ReferenceError`：引用错误，引用了一个不存在的变量或或者对一个不允许改变的变量赋值（例：函数允许结果或this赋值）
3. `RangeError`：值超过有效范围错误，数组下标负值等
4. `TypeError`：类型错误
5. `URIError`：URIError是URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数
6. `EvalError`：eval函数没有被正确执行时，会抛出EvalError错误，

### 自定义错误

Error是基类，其它错误类型都继承自此基类

``` js
function UserError(message) {
  this.message = message || "默认信息";
  this.name = "UserError";
}

UserError.prototype = new Error();
UserError.prototype.constructor = UserError;

new UserError("这是自定义的错误！");
```

### 错误处理 `try cache`

任何没有经过`try...catch...finally`处理的错误都会触发`window`的`error`事件；

``` js
window.onerror = function(message,url,line){
  alert(message);
}
window.addEventListener("error",function(message,url,line){
  alert(message);
});
```

大多数情况下我们是在具体业务代码中使用`try...catch...finally`进行错误处理兼容。

``` js
function f() {
  try {
      console.log(0);
      throw "bug";
  } catch(e) {
      console.log(1);
      return true; // 这句原本会延迟到finally代码块结束再执行
      console.log(2); // 不会运行
  } finally {
      console.log(3);
      return false; // 这句会覆盖掉前面那句return
      console.log(4); // 不会运行
  }
  console.log(5); // 不会运行
}
```

## 错误抛出 `throw`

`throw`用于抛出错误，可以接受各种值作为参数。JavaScript引擎一旦遇到`throw`语句，就会停止执行后面的语句，并将`throw`语句的参数值，返回给用户

``` js
function UserError(message) {
  this.message = message || "默认信息";
  this.name = "UserError";
}

UserError.prototype.toString = function (){
  return this.name + ': "' + this.message + '"';
}

throw new UserError("出错了！");
```

## 异步错误处理

同步任务中我们可以使用`try catch`语句捕获程序错误并做处理，但是异步任务中抛出的错误无法被捕获，看下面的例子

``` js
function main() {
  try {
    setTimeout(() => {
      throw new Error('async error')
    }, 1000)
  } catch(e) {
    console.log(e, 'err')
    console.log('continue...')
  }
}
main();
```

这段代码在`setTimeout`中`throw`的错误并没有被捕捉到，程序直接报错崩溃。JavaScript异步任务是在独立的进程中执行，上面的代码在异步任务在执行完成加入event loop时，主进程已经执行完成出栈，这时主进程的执行上下文已经改变，这时主线程中的`try`无法捕获`callback`中抛出的错误。

### `Promise`错误捕获

`Promise`中抛出的错误只能通过`promise.catch`捕获，`promise`内部的无论是 `reject` 或者 `throw new Error`，都可以通过 `catch` 回调捕获。

``` js
const p1 = new Promise((reslove, reject) => {
  if(1) {
    reject();
  }
});
p1.catch((e) => console.log('p1 error'));

const p2 = new Promise((reslove, reject) => {
  if(1) {
    throw new Error('p2 error')
  }
});
p2.catch((e) => console.log('p2 error'));
```

promise内部的异步任务中的`reject`也可以使用`promise.catch`捕获，但是异步任务中`throw`的错误无法使用`promise.catch`捕捉

``` js
const p3 = () =>  new Promise((reslove, reject) => {
  setTimeout(() => {
    reject('async error');
  })
});

function main3() {
  p3().catch(e => console.log(e));
}
main3();
```

### `async/await`异常捕获

## 参考

[JS 异步错误捕获二三事](https://github.com/sunyongjian/blog/issues/40)
[错误处理机制](http://javascript.ruanyifeng.com/grammar/error.html)
