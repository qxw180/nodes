# 基于已有类型定义创建新的类型

类型直接经常会有一些关系(包含、继承、取反...)，如果忽略这其中的关系，独立的定义各种类型会有以下缺点：

1. 产生重复的类型声明
2. 某个逻辑的变动，需要在多处进行修改

## 类型运算符

在 TS 中可以使用`typeof`运算符获取**变量或者属性**的类型。注意：可以直接从值中提取类型，而不是由一个类型转换为另一个类型。

```TypeScript
let s = "hello";
let n: typeof s; // 等价于 let n: string
```

在 TS 中可以使用`keyof`运算符获取某对象的全部 key 值，并返回这些 key 值的联合类型

```TypeScript
interface Person {
  name: string;
  age: number;
}

type K1 = keyof Person; // "name" | "age"

function getProp<T extends object, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}
```

在 TS 中可以使用`in`操作符遍历枚举类型

```TypeScript
type Keys = "a" | "b" | "c"
type Obj =  {
  [p in Keys]: any
}
// 相当于有
type Obj =  {
  a: any;
  b: any;
  c: any;
}
```

## 映射类型(Mapped Types)

使用索引签名语法，获取已声明类型作作为 key 值，通常配合`keyof`使用。

TODO: Utility Types

如何获取某个 react 组件的全部属性列表，场景 select 组件二次封装，支持现有全部属性
