# 类型定义和使用

## Type Annotations(类型注释) & Types by Inference(类型推断)

我们可以在变量名后使用`:`为变量添加类型注释，明确的告诉 TS 这个变量的类型。

在某些场景下 TS 会自动生成类型，比例在声明变量并赋值是，TS 会使用赋值变量的类型作为变量的类型。`let max = 12`等同于`let max:number = 12`

```TypeScript
// 声明时未指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。
let myFavoriteNumber = 'seven';
myFavoriteNumber = 7; // 编译时报错
// 相当于
let myFavoriteNumber: string = 'seven';
myFavoriteNumber = 7;
```

## Defining Types(类型定义)

在大多数场景针对复杂的类型，我们通常需要复用。 主要有以下两种实现方式：

1. interface declaration：
2. type alias：为某类型起一个别名

### type aliases(类型别名)

可以使用`type`关键字给一个类型起一个新的名字，可以是任意类型(对象、数组、联合类型等等)
应用场景：字符串字面量类型，用来约束字符串变量只能为固定的值

```TypeScript
// 为联合类型命名
type ID = number | string;

// 为对象命名
type Person = {
    id: ID;
    name: string;
}

// 为某些具体值，设置别名。

// 应用场景一：约束监听事件类型
type EventNames = 'click' | 'scroll' | 'mousemove';
function handleEvent(ele: Element, event: EventNames) {
    // do something
}

handleEvent(document.getElementById('hello'), 'scroll');  // 没问题
handleEvent(document.getElementById('world'), 'dbclick'); // 报错，event 不能为 'dbclick'
```

### interfaces(接口)

interface 是用来描述对象的 shape。

```TypeScript
interface Person {
    readonly id: number; // 只读类型
    name: string;
}

// 重复使用interface可实现extends
interface Person {
    age?: number; // 可选属性
    [propName: string]: any; // 任意属性，
}

let tom: Person = {
    name: 'Tom',
    age: 25，
    gender: 'male'
};
```

### 区别&选择

这两种方式都可以用来进行 shape 描述，TS 推荐优先使用 interfaces 因为 interfaces 有更好的错题提示

interfaces 的所有特性几乎都可以使用 type aliases 实现，主要区别是 type aliases 是不能被 re-open 进行属性修改，interfaces 可以通过`extends`实现继承，另外重复的 interface 声明会自定继承。

```TypeScript
// 接口继承
interface Student extends Person {
    class: string;
}

// 别名实现继承：使用交叉类(&)型变相实现
type Bear = Animal & {
    honey: boolean
}
```
