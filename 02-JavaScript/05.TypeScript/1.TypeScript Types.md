# TypeScript Types

## JavaScript 原生类型

```TypeScript
let isDone: boolean = false;
let min: number = 6;
let max: bigint = 9007199254740991n;
let name: string = "bob";
let s1: symbol = Symbol('foo')

// Null 和 Undefined
let u: undefined = undefined;
let n: null = null;
```

## TypeScript 拓展类型

### 任意值 any

允许在程序运行过程中改变变量的类型

```TypeScript
let myFavoriteNumber: any = 'seven';
myFavoriteNumber = 7;

// 变量声明时未指定类型，会被识别为任意值类型
let something;
something = 'seven';
something = 7;
```

### 未知类型 unknown

标识变量或属性的类型未知，要求进行类型缩小

```TypeScript
const jsonParserUnknown = (jsonString: string): unknown => JSON.parse(jsonString);

const myOtherAccount = jsonParserUnknown(`{ "name": "Samuel" }`);
// 因为TS无法知道myOtherAccount的shape，会报错
myOtherAccount.name;

type User = { name: string };
// unknown类型的变量在使用前声明shape
const myUserAccount = jsonParserUnknown(`{ "name": "Samuel" }`) as User;
myUserAccount.name;
```

### void 和 never

- `void`：函数无返回或者返回值为`undefined`
- `never`：表示永远不存在的值的类型(函数抛出异常或死循环的时候无法获得返回值)，通常配合其他类型一起使用

```TypeScript
// 函数的返回值可能为undefined或者可以出现异常无法正常完成函数执行
function alertName(): void | never {
    alert('My name is Tom');
}

type Foo = string | number;
function controlFlowAnalysisWithNever(foo: Foo) {
  if (typeof foo === "string") {
      doSomething()
  } else if (typeof foo === "number") {
      doSomething()
  } else {
    const check: never = foo;
  }
}
// 当 Foo 被修改为 string | number | boolean 时， TS编译会报错，因为else分支内类型可能为boolean
// 使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码
```

## 联合类型(Union Types)

表示值可以为多种类型中的一种

```TypeScript
let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
myFavoriteNumber = 7;

// 只能访问此联合类型的所有类型里共有的属性或方法：
function getLength(something: string | number): number {
    return something.toString(); // OK
    return something.length; // 编译时报错
}

// 联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：
let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
console.log(myFavoriteNumber.length); // 5
myFavoriteNumber = 7;
console.log(myFavoriteNumber.length); // 编译时报错
```

## 数组(Arrays) & 元祖(Tuples)

```TypeScript
let list: number[] = [1, 2, 3];
let list: Array<number> = [1, 2, 3]; // 数组泛型
 // 只读数组
let list: ReadonlyArray<number> = [1, 2, 3];
let list: readonly number[] = [1, 2, 3]; // 是 ReadonlyArray 的简写语法


// 元组 Tuple，表示已知元素数量和类型的数组
let x: [string, number] = ['hello', 10];
// 当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：
tom.push(true); // 编译报错，因为元组元素不包含boolean类型
// 元祖可选元素
let y: [number, string?] = [10];
// 只读元组
let y: readonly [number, string] = [10, 'hi'];
```

## 枚举(Enums)

枚举并不是用于在编辑阶段的类型注释、定义和检测
而是在运行环境增加的一种新特性、新的数据类型，用来定义一组常量。

```TypeScript
enum Direction {
    Up,
    Down,
    Left,
    Right,
}
console.log(Direction.Up); // 0
console.log(Direction[0]); // Up
```

## 字面量类型(Literal Types)&字面量推断(Literal Inference)

在 TS 中字面量不仅只可以作为值来使用，还可以用来表示类型，即字面量类型。
TS 支持三种字面量类型，字符串字面量类型、数字字面量类型、布尔字面量类型，**字面量类型是对应类型的子集**。
单独使用字面量类型往往没有什么实际应用场景，字面量类型通常和联合类型结合使用，用来约束变量的值范围。

```TypeScript
let name: 'lee' | 'rose' = 'lee';
name = 'james'; // 会报错，因为变量lee的类型为字面量类型所以只能被赋值为lee或rose
```

对于一个对象，TS 会对对象的属性进行类型推断。

```TypeScript
const req = { url: "https://example.com", method: "GET" };
handleRequest(req.url, req.method);
// 报错：Argument of type 'string' is not assignable to parameter of type '"GET" | "POST"'.
```

因为对象的属性是可以变的，所以`req`会被推断为`{url: string, method: string}`，可以使用类型断言或`as const`处理。

```TypeScript
const req = { url: "https://example.com", method: "GET" as "GET" };
handleRequest(req.url, req.method as "GET");

// 使用 as const 将对象转属性换为字面量类型
const req = { url: "https://example.com", method: "GET" } as const;
handleRequest(req.url, req.method);
```
