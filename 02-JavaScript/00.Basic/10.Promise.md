# Promise

Promise 对象代表了异步操作的最终完成或失败，Promise 构造函数接收`(resolve, reject) => void`函数对象。在实例化后会**立刻执行**该函数函数，并且**保证异步的返回函数的执行结果**。

Promise 的`then`方法可以实现链式调用，相对于`callback`可以实现更加优异的异步操作状态管理，避免代码陷入回调地狱。

## 基本用法

Promise 对象是一个构造函数，用来生成 Promise 实例，参数是`(resolve, reject) => void`形式的函数，`resolve`和`reject`是函数。

Promise 实例有三种状态，调用`resolve`和`reject`函数可以改变实例的状态，实例的状态转换是**不可逆的**：

- 进行中(Pending)：实例初始状态，Promise 对象创建后会**立即开始执行**传入的函数，实例初始状态为`Pending`。
- 已完成(Resolved)：在函数内调用`resolve`方法后，实例状态转换为`Resolved`
- 已失败(Rejected)：在函数内调用`reject`方法或者在有异常抛出后，实例状态转换为`Rejected`

```JavaScript
var promise = new Promise(function(resolve, reject){
  if (somethingTrue) {
    resolve(value);
  } else {
    reject(err);
  }
});

promise.then(
  (value) => {
    // success
    return data;
  }, (err) => {
    // fail
  }
).then((value) => {}, (err) => {}); // 链式调用
```

使用实例的`then()`方法可以指定 Resolved 和 Rejected 的回调函数，`then()`方法会返回一个新的 Promise 对象，所有可以实现链式调用,需要注意：

1. 异步任务执行完成之后不会立刻执行回调函数，会在本轮事件循环之后调用，详见[JavaScript 运行机制](../02.Core/05-运行机制.md)
2. `then`方法即使是在异步任务执行完成之后添加也可以被调用，并且不限制调用次数
3. 多次调用`then`可以添加多个回调函数，并且会按照插入顺序执行
4. `then`方法的返回值可以在下一个`then`方法收接受
5. `then`方法抛出异常会在调用链的下一个`cache`方法中捕获，在捕获之前的`then`方法会跳过
6. `cache`方法后的`then`方法还会被继续调用

```JS
const p = new Promise((resolve, reject) => {
    resolve(123);
});
p.then((value) => {
  console.log('first then')
  console.log(value)
  return 456;
}).then((value) => {
  console.log('first then.then')
  console.log(value)
})

p.then((value) => {
  console.log('second then')
  console.log(value)
  throw 'test error'
}).then((value) => {
  // 会被跳过
  console.log(value)
}, (error) => {
  console.log('second then.cache')
  console.log(error)
  return 'error fixed'
}).then((value) => {
  console.log(value)
})
// 输出顺序
// first then
// 123
// second then
// 123

// first then.then
// 456
// second then.cache
// test error

// error fixed
```

注意：**调用`resolve`或者`reject`方法更新实例状态后，并不会终止实例函数内部剩余代码执行**

## 实例方法

- `Promise.prototype.then(successCallback, failureCallback): Promise`：Promise 实例状态改变后的回调函数
  - `successCallback`：Resolved 状态回调函数
  - `failureCallback`：Rejected 状态回调函数
  - 返回值：一个新的 Promise 实例
- `Promise.prototype.catch(failureCallback)`：是`.then(null, failureCallback)`的简写，用于指定错误时的回调函数
  - 参数：`failureCallback`：Rejected 状态回调函数
  - 返回值：一个新的 Promise 实例
- `Promise.prototype.finally(onFinally)`：在 promise 结束时，无论结果是 `resolved` 或者是 `rejected`，都会执行指定的回调函数
  - 参数： `onFinally`：回调函数

## 静态方法

- `Promise.resolve(value)`：返回一个状态为 `resolved` 的 Promise 实例
- `Promise.reject(reason)`：返回一个状态为 `rejected` 的 Promise 实例
- `Promise.all(iterable)`：将多个 Promise 实例包装成一个 Promise 实例
  - 参数： `iterable`：Promise iterable 类型数据
  - 返回值：一个新的 Promise 实例
    - 只有参数中所有的实例都为 `resolved`，返回实例的状态才为 `resolved`，返回值为所以实例返回值的数组
    - 只要参数中有一个实例的状态为 `rejected`，返回实例的状态即为 `rejected`，返回值为第一个 `rejected` 实例的值
- `Promise.allSettled(iterable)`：类似`Promise.all()`，区别不关心每个 promise 的状态，等全部 promise 对象状态确认后返回一个数字对象，对应每个 promise 的结果。
- `Promise.race(iterable)`：将多个 Promise 实例包装成一个 Promise 实例
  - 参数： `iterable`：Promise iterable 类型数据
  - 返回值：一个新的 Promise 实例，只要实例数组中有一个实例的状态改变，返回实例的状态就改变，值为第一个改变实例的值
- `Promise.any(iterable)`：类似`Promise.race()`，区别是等到第一个 resolve 的 promise 并返回

## [异常处理](../02.Core/04-异常处理.md)

Promise 实例内函数抛出的异常不能被`try catch`语句捕获，只能在实例回调函数`then`或`catch`内处理

`catch`和`then`的第二个参数是一样的，是`.then(null, (err) => {})`的简写，区别是`catch`还可以捕获`then`方法内抛出的异常。

TODO: 当 Promise 对象被 Reject 后会派发全局事件，如果有`reject`函数处理会抛出`rejectionhandled`事件，否则会抛出`unhandledrejection`

```JS
window.addEventListener("unhandledrejection", event => {
  /* 你可以在这里添加一些代码，以便检查
     event.promise 中的 promise 和
     event.reason 中的 rejection 原因 */
  event.preventDefault();
}, false);
```

## Polyfill

```JS

const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

class MyPromise {

  #status = PENDING;
  #value = null;
  #reason = null;
  #fulfilledCallbackQueue = [];
  #rejectedCallbackQueue = [];

  constructor(executor) {

    const resolver = (value) => {
      if (this.#status === PENDING) {
        this.#value = value;
        this.#status = FULFILLED;
        while (this.#fulfilledCallbackQueue.length) {
          this.fulfilledCallbackQueue.shift()(value);
        }
      }
    }
    const reject = (reason) => {
      if (this.#status === PENDING) {
        this.#reason = reason
        this.#status = REJECTED;
        while (this.#rejectedCallbackQueue.length) {
          this.#rejectedCallbackQueue.shift()(reason);
        }
      }
    }

    executor(resolve, reject);
  }

  then(onFulfilled, onRejected) {
    return new MyPromise(resolve, reject) {
      const fulfilledFn = value => {
        try {
          const v = onFulfilled(value);
          v instanceof MyPromise ? v.then(resolve, reject) : resolve(v);
        } catch (err) {
          reject(err)
        }
      }
      this.fulfilledCallbackQueue.push(fulfilledFn);

      const rejectedFn  = reason => {
        try {
          const v = onRejected(reason)
          v instanceof MyPromise ? v.then(resolve, reject) : resolve(v)
        } catch (err) {
          reject(err)
        }
      }
      this.rejectedCallbackQueue.push(rejectedFn);
    }
  }

  cache(onRejected) {
    return this.then(null, onRejected);
  }

  static all(promises) {}
}
```
