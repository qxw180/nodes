#需要注意的基本语法

##作用域(Scoping)
+ JavaScript只有函数作用域(Function Scoping)，没有块级作用域(Block Scoping)；
+ 函数内部使用`var`声明的变量作用域为函数内部；
+ 在函数外部声明的变量和不声明直接赋值的变量都具有全局作用域，绑定的全局对象上(浏览器的全局对象为`window`)
+ `let`：ES6新引入关键字，可声明块级作用域

---
##`switch`

	switch(sport){
		case "basketball":
			console.log("Tall Man");
			
		case "football":
			console.log("Fast Man");
			
		default:
			console.log("Fattly");
	}

+ `case`语句内的`break`不能少，否则语句会在匹配后执行之后所有`case`和`default`语句中的内容；
+ 如果`case`语句没有匹配，则会执行`default`语句中的内容；
+ `case`语句在进行匹配是使用的是`===`匹配；

---
##`for`和`Object.keys()`的区别
> `for`：会遍历对象继承自原型的属性和方法
> `Object.keys()`：只获取对象本身的属性

---
##`break`、`continue`和`return`
+ `break`：跳出循环
+ `continue`：结束本次循环，进行下一次循环
+ `return`：跳出方法，并返回值

---
##JavaScript严格模式
+ 必须`var`关键字声明变量，不允许对为声明的变量之间赋值；
+ 函数的参数不能同名；
+ `this`不能指向全局对象，默认为`undefined`;
+ 不允许使用`label`；
+ 对`wirtable`属性为`false`进行修改会报错，非严格模式不会报错也不会生效；
+ 不可以`delete``congifrable`为`false`的属性；

---
##IIFE 立即调用函数表达式
> 形成独立作用域，避免污染全局变量
	(function(){
		...	
	})()
---
##eval命令
> `eval()`命令可以把字符串当作语句执行；
> `eval()`没有自己的作用域，执行作用域为当前作用域
	var a = 1;
	eval('a=2');
	console.log(a);// 2
> `eval()`不会得到JavaScript引擎优化，运行速度较慢
> `eval()`间接调用作用域为全局作用域
	var a = 1;
	function f(){
		var a = 2;
		var e = eval;
		e('console.log(a)')
	}
	f();// 1
---
