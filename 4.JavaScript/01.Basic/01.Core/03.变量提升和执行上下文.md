#JavaScript 变量提升和执行上下文

##变量提升(hoisting)
> JavaScript引擎运行方式是先解析代码，获取所有被声明的变量，然后再一行一行的允许。所有的变量声明语句都会被提升到代码的头部；

	console.log(a);//undefined
	var a = 1;
	
	在解析过程变量a被提升到console之前，但是赋值不会被提升；相当于
	var a;
	console.log(a);
	a = 1;
	所以结果为`undefined`

> 变量提升只对`var`语句有效

	console.log(b);//Uncaught ReferenceError: b is not defined(…)
	b = 2;
	JavaScript不会对b = 2进行变量提升，只认为这是一个赋值语句；


##JavaScript引擎工作方式
> JavaScript引擎运行过程分为预编译期和执行器
> 在预编译期会生成执行上下文
> 生成执行上下文的过程就是变量提升的过程

##执行上下文 Execution Context
> EC 是一个栈级结构，栈的底层可以获取上层对象的属性，各执行上下文直接形成一个链形结构，及作用域链

+ 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，
+ 作用域链的变量只能向上访问，变量访问到window对象即被终止，
+ 作用域链向下访问变量是不被允许的。

##变量对象 Variable Object
> VO 是一个抽象概念中的对象，用于存储执行上下文中的变量、函数声明和函数参数；

	var a = 10;      		VO(globalContext) = {
	function test(x){			a:10,
		var b = 20;				test:<ref to function>
	}						};	
	test(30);				VO(test functionContext){
								x:30,
								b:10
							}
> VO的执行顺序如下

1. 函数参数(若未传入，初始化该参数的职位`undefined`)
2. 函数声明(若发生命名冲突，会覆盖)
3. 变量声明(初始化变量值为`undefined`，若发生命名冲突会忽略)

例：

	alert(x); // function x(){} 函数重复声明，覆盖var x

	var x = 10;
	alert(x);// 10 允许时变量赋值
	x = 20;

	function x(){}
	alert(x);// 20

	if(true){
		var a = 1;
	}else{
		var b = true;
	}

	alert(a);// 1
	alert(b);// undefined 变量初始化后为执行赋值

##JavaScript上下文 this
+ 以对象的方法形式调用，this指向被调用的对象；
+ 以单独函数调用，this指向全局变量；
	* 在`use strict`模式下`this`指向`undefined`，可以暴露错误；
+ 使用函数的`apply()`方法可以控制this的指向
	* 第一个参数就是需要绑定的this变量；
	* 第二个参数是Array，表示函数本身的参数；
	* `call()`方法与`apply()`方法功能一直，唯一的区别是`apply()`把参数打包成Array再传入，`call()`把参数按顺序传入。
