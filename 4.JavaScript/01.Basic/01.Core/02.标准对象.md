#JavaScript标准对象

##Array

+ `Array.length`属性返回数组的长度，对其进行赋值会导致`Array`大小的变化，越界的内容会被删除；
+ 可以通过下标索引获取`Array`成员，JavaScript不会发生数组下标越界错误，下标越界时赋值会导致数组大小变化；

常用方法API：

+  `indexOf()`：返回指定元素位置，无匹配返回-1
+  `slice([start][,end])`：数组截取；如果不包含开始和结束位置则截取整个数组，可以用这个方法复制一个数组；
+  `push()`：向末尾添加元素
+  `pop()`：删除最后一个元素
+  `unshift()`：向头部添加一个元素
+  `shift()`：删除头部元素
+  `sort()`：对数组进行排序
+  `reverse()`：数组反转
+  `concat()`：数组拼接
+  `join()`：将数组的元素拼接成字符串并返回
+  `splice(start,length[,element1,element2,...])`：从start位置开始删除length个元素，并从start位置插入element1,element2,...，并返回删除的元素数组；

##Map：ES6引入的新类型，`Map`是一组键值对结构，具有极快的查找速度；
初始化`Map`需要一个二维数组，或空数组

+ `var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);`
	* 获取：`m.get(key)`
	* 设置：`m.set(key,value)`
	* 删除：`m.delete(key)`

##Set：一组不重复的key的集合
初始化`Set`需要一个Array最为输入或空

+ `var s = new Set([1, 2, 3])`
	* 添加：`add(key)`
	* 删除：`delete(key)`

---
##函数

> 函数的声明和变量提升

	使用function命令声明函数
	function f1(attr){
		return attr;
	}

	使用变量赋值声明函数
	var f1 = function(attr){
		return attr;
	}

> 重复声明函数，后声明的函数会覆盖之前声明的函数；
> 使用function命令声明函数会发生变量提升

	function f() {
	  console.log(1);
	}
	f() // 2
	function f() {
	  console.log(2);
	}
	f() // 2

	// 相当于
	function f(){//变量提升
		console.log(1)
	}
	function f(){//函数覆盖
		console.log(2)
	}
	f(); //2
	f(); //2
---

#####函数的属性和方法
+ `.name`：返回函数的名称，使用变量声明的匿名函数返回值为`''`；
+ `.length`：返回函数定义的参数个数，可以利用这个属性实现面向对象编程中的“方法重载”
+ `.toString()`：返回函数的源代码，方法内部注释也会一同返回

#####函数的作用域
> JavaScript中只存在两种作用域，全局作用域和函数作用域

+ 全局作用域：在程序中一直存在；
+ 函数作用域：在函数内部声明的变量，只要在函数内部存在；

> 在函数内部声明的变量优先级高于全局变量

	var x = 1;
	function f(){
		var x = 2;
		console.log(x);
	}
	f(); // 2
> 在函数内部也同样会发生变量提升，其实每个函数允许都会产生一个执行上下文

	(function(){
		console.log(x);
		var x = 12;
	})()
	// 执行结果为unidined，但是不会报错


#####函数的参数
> JavaScript传入的参加个数可以和声明的参数个数不一致，函数的`.length`属性和可以返回声明的参数个数；
> 被忽略的参数的值就为`undefined`

	function f(a,b){
		return a;
	}

	f();//undefined;

> 设置默认值

	function f(a) {
	  (a !== undefined && a !== null) ? a = a : a = 1;
	  return a;
	}

> 同名参数：如果有相同参数名的参数，则取后出现的参数

> arguments对象：包含了函数运行时的所有参数

+ `.lenght`：运行时参数个数
+ `.callee`：返回对应得原函数

---

##Date
	var now = new Date();
	now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
	now.getFullYear(); // 2015, 年份
	now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月
	now.getDate(); // 24, 表示24号
	now.getDay(); // 3, 表示星期三
	now.getHours(); // 19, 24小时制
	now.getMinutes(); // 49, 分钟
	now.getSeconds(); // 22, 秒
	now.getMilliseconds(); // 875, 毫秒数
	now.getTime(); // 1435146562875, 以number形式表示的时间戳

##RegExp
- 匹配项
	+ `\d`：一个数字
	+ `\w`：一个数字或字母
	+ `\s`：一个空格（包括Tab等）
	+ `.`：任意字符
- 长度项
	+ `*`：任意个，包括0个字符
	+ `+`：至少一个字符
	+ `？`：0个或1个字符
	+ `{n}`：n个字符
	+ `{n,m}`：n-m个字符
- 高级项
	+ `[]`：范围，
		* `[a-zA-Z0-9\_]`：匹配数字字母下划线
		* `[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0,19}`：匹配JavaScript变量名（以数字字母下划线开头1-20位）
		* `[j|J]ava[s|S]cprit`：匹配JavaScript不区分大小写
	+ `^`：开始符
	+ `$`：结束符
	+ `()`：分组，

示例代码

	var regPhone = /^\d{3}\-\d{3,8}$/;
	var regPhone2 = new RegExp('/^\d{3}\-\d{3,8}$/');

	var regJS = /[j|J]ava[s|S]cript/g;
	var regJS2 = new RegExp('/[j|J]ava[s|S]cript','g');

	reg.test('reg str');// 测试字符串是否符合表达式
	`reg str`.split(reg);// 字符串切分
	reg.exec('reg str');// 会返回一个`Array`，第一个元素始终是原始字符串本身，后面的字符串表示匹配成功的子串；匹配失败返回`null`；
