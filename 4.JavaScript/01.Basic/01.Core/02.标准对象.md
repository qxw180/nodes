#JavaScript标准对象

##[Object对象](http://javascript.ruanyifeng.com/stdlib/object.html)

####创建对象
+ `{}`：字面量写法
+ `new Object()`：构造函数
	* 出入参数为对象，则直接返回该对象，`var obj = {a:1};obj === new Object(obj);// true`；
	* 传入产生为元素类型，则返回该值的包装类；
	* 通过构造函数与字面量写法是等价的；
+ `Object.create(null)`：创建一个对象，并指定对象的原型

####对象的属性模型
ECMAScript5对应对象的属性都提出了一个精确的模型描述；
每个对象属性都有一个`attributes`对象，用来保存对象属性的描述，称为元信息；
可以通过`Object.getOwnPropertyDescriptor(obj,attr)`方法来获取

	var obj = {a:1};
	Object.getOwnPropertyDescriptor(obj,'a');
	// Object {value: 1, writable: true, enumerable: true, configurable: true}


> 对象属性的元信息主要包括以下内容：

+ `value`：属性的值，默认`undefined`
+ `writable`：表示`value`的值是否可以改变，默认`true`
+ `enumerable`：表示属性是否可枚举，默认`true`；如果设置为`false`在`for`循环和`Object.keys()`中将跳过该属性
+ `configurable`：表示属性是否可以配置，默认`true`；如果为`false`则
	* 不可以使用`delete`删除该属性
	* 除了`value`之外的元信息都不能修改
+ `get`：函数的默认取值函数，默认`undefined`
+ `set`：函数的默认赋值函数，默认`undefined`

#####设置对象属性元信息：
> `Object.defineProperty(object,propertyName,attributesObject)`
> `Object.defineProperties(object,attributesObject)`
	var o = Object.defineProperty({},a,{value:1,wirtable:true,enumerable:true,configurable:true});
	Object.defineProperties({},{
		a:{value:1,wirtable:true,enumerable:true,configurable:true},
		b:{
			wirtable:true,
			enumerable:true,
			configurable:true,
			get:function(){
				return this.a * 2;
			}
		},
	});
> `Object.defineProperty`和`Object.defineProperties`方法效率比较低；
> 设置`get/set`属性后不能将`wriable`设置为`false`，也不能设置`value`，否则会报错；
> `enumerable`、`enumerable`、`configurable`默认都为`false`；

---
#####获取对象属性
+ `Object.getOwnPropertyNames(object)`：获取全部属性，包括`enumerable:false`
+ `Object.keys(object)`：获取`enumerable`不为`false`的属性

---
#####属性验证
是否可枚举：`Object.prototype.propertyIsEnumerable()`

	var o = {};
	o.p = 123;

	o.propertyIsEnumerable("p") // true
	o.propertyIsEnumerable("toString") // false
---
####对象的状态控制
+ `Object.preventExtensions(object)`：阻止对象继续添加属性
+ `Object.isExtensible(object)`：判断对象是否可以添加属性
+ `Object.seal(object)`：锁死对象，无法添加属性，也无法删除属性
+ `Object.isSealed(object)`：判断对象是否锁死
+ `Object.freeze(object)`：冻结对象，无法添加删除属性，也无法修改属性的值
+ `Object.isFrozen(object)`：判断对象是否冻结

####原型链相关
+ `Object.create(object)`：生成一个新对象，并该对象的原型。
+ `Object.getPrototypeOf(object)`：获取对象的Prototype对象。

####对象实例方法：
+ `valueOf()`：返回当前对象对应值，主要用途自动类型转换会调用该方法
	可以重写覆盖该方法实现自己想要的效果
	var o = new Object();
	o.valueOf = function (){return 2;};
	1 + o // 3
+ `toString()`：返回当前对象对应字符串形式，可以自定义toString方法，得到想要的字符串形式
+ `propertyIsEnumerable(attr)`：判断对象属性是否可枚举
+ `hasOwnProperty()`：判断某个属性是否为当前对象自身的属性
+ `isPrototypeOf()`：判断当前对象是否为另一个对象的原型

---
##Array

+ `Array.length`属性返回数组的长度，对其进行赋值会导致`Array`大小的变化，越界的内容会被删除；
+ 可以通过下标索引获取`Array`成员，JavaScript不会发生数组下标越界错误，下标越界时赋值会导致数组大小变化；

常用方法API：

+  `indexOf()`：返回指定元素位置，无匹配返回-1
+  `slice([start][,end])`：数组截取；如果不包含开始和结束位置则截取整个数组，可以用这个方法复制一个数组；
+  `push()`：向末尾添加元素
+  `pop()`：删除最后一个元素
+  `unshift()`：向头部添加一个元素
+  `shift()`：删除头部元素
+  `sort()`：对数组进行排序
+  `reverse()`：数组反转
+  `concat()`：数组拼接
+  `join()`：将数组的元素拼接成字符串并返回
+  `splice(start,length[,element1,element2,...])`：从start位置开始删除length个元素，并从start位置插入element1,element2,...，并返回删除的元素数组；

##Map：ES6引入的新类型，`Map`是一组键值对结构，具有极快的查找速度；
初始化`Map`需要一个二维数组，或空数组

+ `var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);`
	* 获取：`m.get(key)`
	* 设置：`m.set(key,value)`
	* 删除：`m.delete(key)`

##Set：一组不重复的key的集合
初始化`Set`需要一个Array最为输入或空

+ `var s = new Set([1, 2, 3])`
	* 添加：`add(key)`
	* 删除：`delete(key)`

---
##函数

> 函数的声明和变量提升

	使用function命令声明函数
	function f1(attr){
		return attr;
	}

	使用变量赋值声明函数
	var f1 = function(attr){
		return attr;
	}

> 重复声明函数，后声明的函数会覆盖之前声明的函数；
> 使用function命令声明函数会发生变量提升

	function f() {
	  console.log(1);
	}
	f() // 2
	function f() {
	  console.log(2);
	}
	f() // 2

	// 相当于
	function f(){//变量提升
		console.log(1)
	}
	function f(){//函数覆盖
		console.log(2)
	}
	f(); //2
	f(); //2
---

#####函数的属性和方法
+ `.name`：返回函数的名称，使用变量声明的匿名函数返回值为`''`；
+ `.length`：返回函数定义的参数个数，可以利用这个属性实现面向对象编程中的“方法重载”
+ `.toString()`：返回函数的源代码，方法内部注释也会一同返回

#####函数的作用域
> JavaScript中只存在两种作用域，全局作用域和函数作用域

+ 全局作用域：在程序中一直存在；
+ 函数作用域：在函数内部声明的变量，只要在函数内部存在；

> 在函数内部声明的变量优先级高于全局变量

	var x = 1;
	function f(){
		var x = 2;
		console.log(x);
	}
	f(); // 2
> 在函数内部也同样会发生变量提升，其实函数每次执行都会产生一个执行上下文

	(function(){
		console.log(x);
		var x = 12;
	})()
	// 执行结果为unidined，但是不会报错


#####函数的参数
> JavaScript传入的参加个数可以和声明的参数个数不一致，函数的`.length`属性和可以返回声明的参数个数；
> 被忽略的参数的值就为`undefined`

	function f(a,b){
		return a;
	}

	f();//undefined;

> 设置默认值

	function f(a) {
	  (a !== undefined && a !== null) ? a = a : a = 1;
	  return a;
	}

> 同名参数：如果有相同参数名的参数，则取后出现的参数

> arguments对象：包含了函数运行时的所有参数

+ `.lenght`：运行时参数个数
+ `.callee`：返回对应得原函数

---

##Date
	var now = new Date();
	now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
	now.getFullYear(); // 2015, 年份
	now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月
	now.getDate(); // 24, 表示24号
	now.getDay(); // 3, 表示星期三
	now.getHours(); // 19, 24小时制
	now.getMinutes(); // 49, 分钟
	now.getSeconds(); // 22, 秒
	now.getMilliseconds(); // 875, 毫秒数
	now.getTime(); // 1435146562875, 以number形式表示的时间戳

##RegExp
- 匹配项
	+ `\d`：一个数字
	+ `\w`：一个数字或字母
	+ `\s`：一个空格（包括Tab等）
	+ `.`：任意字符
- 长度项
	+ `*`：任意个，包括0个字符
	+ `+`：至少一个字符
	+ `？`：0个或1个字符
	+ `{n}`：n个字符
	+ `{n,m}`：n-m个字符
- 高级项
	+ `[]`：范围，
		* `[a-zA-Z0-9\_]`：匹配数字字母下划线
		* `[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0,19}`：匹配JavaScript变量名（以数字字母下划线开头1-20位）
		* `[j|J]ava[s|S]cprit`：匹配JavaScript不区分大小写
	+ `^`：开始符
	+ `$`：结束符
	+ `()`：分组，

示例代码

	var regPhone = /^\d{3}\-\d{3,8}$/;
	var regPhone2 = new RegExp('/^\d{3}\-\d{3,8}$/');

	var regJS = /[j|J]ava[s|S]cript/g;
	var regJS2 = new RegExp('/[j|J]ava[s|S]cript','g');

	reg.test('reg str');// 测试字符串是否符合表达式
	`reg str`.split(reg);// 字符串切分
	reg.exec('reg str');// 会返回一个`Array`，第一个元素始终是原始字符串本身，后面的字符串表示匹配成功的子串；匹配失败返回`null`；

