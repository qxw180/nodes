#JavaScript 面向对象编程

##构造函数 Constructor
构造函数是生成对象的模版
在Java等面向对象的编程语言中存在类(class)的概念，用来编写对象的模版
但是ES5规范里并没有类的概念，而是基于构造器和原型链来实现类和继承

---
####构造函数的原理

其实构造函数本身只是一个函数，当一个普通的函数遇上关键字`new`，那神器的事情就发生了

函数每次执行都有返回值，如果没有声明返回值则默认返回`undefined`
	
	function A(x){
		return x * 2;
	}
	function B(x){
		x *= 2;
	}

	A(2);// 4
	B(2);// undefined;

当使用`new`执行函数的时候返回值就不一样了
`new`关键字会开辟一块内存空间，在函数内部，`this`就执行这块内存空间
这时如果函数不声明返回值，或者声明的返回值为基本类型，那么返回值为`this`
如果返回类型为`object`那么就返回这个`object`
这样通过`new`关键字就使一个普通的函数变成了生成对象的模版
可以在函数内部通过`this`关键字在生成的对象实例上生成属性和方法

	function A(x,y){
		this.x = x;
		this.y = y;
		this.toString = function(){
			return this.x + this.y;
		}
	}

	function B(x,y){
		this.x = x;
		this.y = y;
		this.toString = function(){
			return this.x + this.y;
		}

		return "Constructor return base Type";
	}

	function C(x,y){
		this.x = x;
		this.y = y;
		this.toString = function(){
			return this.x + this.y;
		}

		return {x:x,y:y};
	}
	
	A(1,2);// undefined;
	var a = new A(1,2);
	a.toString();// 3;

	B(1,2);// "Constructor return base Type"
	var b = new B(1,2);
	b.toString();// 3;
	
	C(1,2); // Object {x: 1, y: 2}
	var c = new C(1,2);
	c.toString();// "[object Object]"

在上面的例子中方法A和方法B中由于没有声明返回类型或者声明的返回类型为基本类型，所以声明了也白声明，返回的为新开辟的内存空间，即this所指向的部分；
在方法中均对`toSting()`方法进行覆盖，所以通过方法A和方法B生成的实例调用`toString`方法时指向的是我们自己声明的方法；
在方法C中因为返回类型是一个对象，那么生成的实例即为这个对象，覆盖的`toString`方法并没有生效，调用的仍然是继承自Object的`toString`方法；

由此看见我们声明的构造函数如果不通过`new`关键字调用那么就不是我们想要的效果，
我可以通过以下两种方式处理这个问题

1.使用严格模式，没有使用`new`关键字，严格模式下函数内部`this`不能指向全局对象，默认等于`undefined`，对`undefined`进制操作会报错

	function A(x){
		'use strict';
		this.x = x;
	}
	A(1); //Uncaught TypeError: Cannot set property 'x' of undefined(…)

2.在构造函数内部进行判断;

	function A(x){
		if(!(this instanceof A)){
			return new A(x);
		}
		this.x = x;
	}


---

##OOP核心-封装
> 面向对象开发的本质是为了对复杂的事物进行简化
> 将我们关系的属性和行为抽象出来，封装成一个对象
> 这更符合我们的思维，更加灵活，有利于重用和维护

进行OOP开发的第一步就是进行抽象和封装
例如我们对人的特征进行提取，我们首先找出来我们关系的点，例如我们关心人体的结构(姓名、性别...)和日常行为(走路、说话...)
特征的提取就是我们抽象的过程，完成了抽象的过程我们就可以对我们抽象出的人进行封装

	function Person(name,sex){
		this.name = name;
		this.sex = sex;
		this.walk = function(){
			console.log("walking...")
		}
		this.speak = function(word){
			console.log("Speaking:" + word);
		}
	}

这样我们完成了抽象和封装，获得一个人的模版，我们用这个模块就可以量产人了(程序届这个事情是不是太简单了哈哈)

	var david = new Person("David","boy");
	var lucy = new Person("Lucy","girl");

是不是很爽，随随便便就可以new一个人了，确实不错，但是有一个缺点
在我们new出来的David和Lucy中都有walk和speak两个方法，这两个方法完全一致的，但是David和Lucy每个人都有一份
这就造成了对系统资源的浪费
在Java等面向对象的语言中会有底层的优化，JavaScript的实现不是自动的，是通过`prototype`对象来完成的

#####JavaScript继承机制设计
> 在JavaScript中每个*对象(函数)*都有一个属性`prototype`被称为原型对象；
> 定义在原型对象上的属性和方法都可以被函数派生出的实例继承；

我们对上面的代码进行一下改造
	
	function Person(name,sex){
		this.name = name;
		this.sex = sex;
	}
	Person.prototype.speak = function(word){
		console.log(this.name + " say " + word);
	}

	var lee = new Person("Lee","man");
	lee.speak('Hello');// "Lee say Hello"

这样就实现了方法的公用
同时我们对`prototype`对象进行就该就能够立刻在所有生成的对象实例生效
这也是JavaScript继承机制的强大之处，可以在允许的过程中对预定义的行为进行修改

---
JavaScript没有实现方法的重载，我们可以通过判断参数的个数和类型进行方法的重载

	Person.prototype.walk = function(speed,direction){
		if(arguments.length == 1){
			console.log(this.name + " is walking by " + speed + "km/s");
		}else{
			console.log(this.name + " is walking to " + direction +" by " + speed + "km/s");
		}
	}

	lee.walk(1000);// Lee is walking by 1000km/s
	lee.walk(1000,'east');// Lee is walking to east by 1000km/s
---
#####原型链prototype chain
> JavaScript的所有的实例对象都是由构造函数派生的，而每个构造函数都有`prototype`属性，所以所有对象都有自己的`prototype`原型对象；
> 在获取实例对象的属性或方法的时候，首先会在对象的自身进行查找，如果没有就去原型对象上查找
> 由于原型对象本身也是对象也有自己的原型，在实例对象的原型对象上查找不到属性就会向原型对象的原型对象继续发起查询，知道尽头(null)
> 这就形成了一个链形的结构即原型链；
> 最终的源头就是Object，所有的对象都是Object构造函数生成的，Object的也有`prototype`对象，Object的prototype属性指向`null`
	
	Object.getPrototypeOf(Person.prototype);// Object {}
	Object.getPrototypeOf(Person.prototype) == Object.prototype;// true
	Object.getPrototypeOf(Object.prototype);// null

> 每个prototype都有一个constructor属性，默认指向prototype对象所在的构造函数
	
	Person.prototype.constructor === Person;// true 

> 原型链相关方法

`Object.getPrototypeOf`：方法返回一个对象的原型。
	
	Object.getPrototypeOf({}) === Object.prototype;// true

`Object.create`：用于生成对象，并且制定生成对象的原型
	
	var lee2 = Object.create(lee);
	Object.getPrototypeOf(tt) === lee;// true

`isPrototypeOf`：用来判断一个对象是否是另一个对象的原型。

	lee.isPrototypeOf(lee2);// true

##OOP核心-继承
##OOP核心-多态